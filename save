#include "lem_in.h"

static inline t_rm  *find_start(t_rm *start)
{
    t_rm            *tmp;

    tmp = start;
    while (tmp)
    {
        if (tmp->is_start)
            return (tmp);
        tmp = tmp->next;
    }
    return (tmp);
}

void	ft_lstdelete(t_list **alst)
{
	if (alst && *alst)
	{
		while (*alst)
		{
			free(*alst);
			*alst = (*alst)->next;
		}
		*alst = NULL;
	}
}

static inline t_rm  *find_black_room(t_link *room)
{
    t_link  *tmp;

    tmp = room;
    while (tmp)
    {
        if (tmp->room->len == -1)
            return (tmp->room);
        tmp = tmp->next;
    }
    return (NULL);
}

static inline t_rm  *find_end(t_rm *start)
{
    t_rm            *tmp;

    tmp = start;
    while (tmp)
    {
        if (tmp->is_end)
            return (tmp);
        tmp = tmp->next;
    }
    return (tmp);
}

static inline void  fill_len(t_rm *start)
{
    t_rm			*tmp_start;
    t_rm			*save;
    t_q				*que;
    t_q             *start_que;
    int             len;

    len = 1;
	que = ft_memalloc(sizeof(t_q));
    start_que = que;
    tmp_start = find_start(start);
    while (tmp_start)
    {
        save = tmp_start;
    	while (save->link)
        {
			start_que = ft_memalloc(sizeof(t_q));
            if (save->link->room->len == -1)
            {
                start_que->room = save->link->room;
                start_que = start_que->next;
            }
            // save = find_black_room(tmp_start->link)
    		// break ;
            save->link = save->link->next;
        }
        while (tmp_start->link)
        {
            if ((tmp_start->link->room->len > len) || (tmp_start->link->room->len == -1))
                tmp_start->link->room->len = len;
            tmp_start->link = tmp_start->link->next;
        }
        len++;
        tmp_start = que->room;
        que = que->next;
    }
}

void				algorithm(t_lm *lm)
{
	fill_len(lm->start);
}
